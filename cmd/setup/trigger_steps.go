package setup

import (
	"fmt"

	"github.com/zitadel/zitadel/internal/database"
	"github.com/zitadel/zitadel/internal/domain"
	"github.com/zitadel/zitadel/internal/migration"
	"github.com/zitadel/zitadel/internal/query/projection"
)

// triggerSteps defines the repeatable migrations that set up triggers
// for counting resources in the database.
func triggerSteps(db *database.DB) []migration.RepeatableMigration {
	return []migration.RepeatableMigration{
		// Delete parent count triggers for instances and organizations
		migration.DeleteParentCountsTrigger(db,
			projection.InstanceProjectionTable,
			domain.CountParentTypeInstance,
			projection.InstanceColumnID,
			projection.InstanceColumnID,
			"instance",
		),
		migration.DeleteParentCountsTrigger(db,
			projection.OrgProjectionTable,
			domain.CountParentTypeOrganization,
			projection.OrgColumnInstanceID,
			projection.OrgColumnID,
			"organization",
		),

		// Count triggers for all the resources
		migration.CountTrigger(db,
			projection.OrgProjectionTable,
			domain.CountParentTypeInstance,
			projection.OrgColumnInstanceID,
			projection.OrgColumnInstanceID,
			"organization",
		),
		migration.CountTrigger(db,
			projection.ProjectProjectionTable,
			domain.CountParentTypeOrganization,
			projection.ProjectColumnInstanceID,
			projection.ProjectColumnResourceOwner,
			"project",
		),
		migration.CountTrigger(db,
			projection.UserTable,
			domain.CountParentTypeOrganization,
			projection.UserInstanceIDCol,
			projection.UserResourceOwnerCol,
			"user",
		),
		migration.CountTriggerConditional(db,
			projection.UserTable,
			domain.CountParentTypeOrganization,
			projection.UserInstanceIDCol,
			projection.UserResourceOwnerCol,
			"service_user",
			false, // the user type cannot change, so we do not need to track updates
			&migration.TriggerCondition{
				Column: projection.UserTypeCol,
				// since we marshal the value into and from json,
				// we directly use the float64 value to prevent issues with the comparison of the previous migration
				Value: float64(2),
			},
		),
		migration.CountTrigger(db,
			projection.InstanceMemberProjectionTable,
			domain.CountParentTypeInstance,
			projection.MemberInstanceID,
			projection.MemberResourceOwner,
			"iam_admin",
		),
		migration.CountTrigger(db,
			projection.IDPTable,
			domain.CountParentTypeInstance,
			projection.IDPInstanceIDCol,
			projection.IDPInstanceIDCol,
			"identity_provider",
		),
		migration.CountTrigger(db,
			projection.IDPTemplateLDAPTable,
			domain.CountParentTypeInstance,
			projection.LDAPInstanceIDCol,
			projection.LDAPInstanceIDCol,
			"identity_provider_ldap",
		),
		migration.CountTrigger(db,
			projection.ActionTable,
			domain.CountParentTypeInstance,
			projection.ActionInstanceIDCol,
			projection.ActionInstanceIDCol,
			"action_v1",
		),
		migration.CountTrigger(db,
			projection.ExecutionTable,
			domain.CountParentTypeInstance,
			projection.ExecutionInstanceIDCol,
			projection.ExecutionInstanceIDCol,
			"execution",
		),
		migration.CountTrigger(db,
			fmt.Sprintf("%s_%s", projection.ExecutionTable, projection.ExecutionTargetSuffix),
			domain.CountParentTypeInstance,
			projection.ExecutionTargetInstanceIDCol,
			projection.ExecutionTargetInstanceIDCol,
			"execution_target",
		),
		migration.CountTrigger(db,
			projection.LoginPolicyTable,
			domain.CountParentTypeInstance,
			projection.LoginPolicyInstanceIDCol,
			projection.LoginPolicyInstanceIDCol,
			"login_policy",
		),
		migration.CountTriggerConditional(db,
			projection.LoginPolicyTable,
			domain.CountParentTypeInstance,
			projection.LoginPolicyInstanceIDCol,
			projection.LoginPolicyInstanceIDCol,
			"enforce_mfa",
			true,
			&migration.OrCondition{
				Conditions: []migration.TriggerCondition{
					{Column: projection.LoginPolicyForceMFACol, Value: true},
					{Column: projection.LoginPolicyForceMFALocalOnlyCol, Value: true},
				},
			},
		),
		migration.CountTrigger(db,
			projection.PasswordComplexityTable,
			domain.CountParentTypeInstance,
			projection.ComplexityPolicyInstanceIDCol,
			projection.ComplexityPolicyInstanceIDCol,
			"password_complexity_policy",
		),
		migration.CountTrigger(db,
			projection.PasswordAgeTable,
			domain.CountParentTypeInstance,
			projection.AgePolicyInstanceIDCol,
			projection.AgePolicyInstanceIDCol,
			"password_expiry_policy",
		),
		migration.CountTrigger(db,
			projection.LockoutPolicyTable,
			domain.CountParentTypeInstance,
			projection.LockoutPolicyInstanceIDCol,
			projection.LockoutPolicyInstanceIDCol,
			"lockout_policy",
		),
		migration.CountTriggerConditional(db,
			projection.NotificationPolicyProjectionTable,
			domain.CountParentTypeInstance,
			projection.NotificationPolicyColumnInstanceID,
			projection.NotificationPolicyColumnInstanceID,
			"password_change_notification",
			true,
			&migration.TriggerCondition{
				Column: projection.NotificationPolicyColumnPasswordChange,
				Value:  true,
			},
		),
		migration.CountTriggerConditional(db,
			projection.UserMetadataProjectionTable,
			domain.CountParentTypeOrganization,
			projection.UserMetadataColumnInstanceID,
			projection.LockoutPolicyResourceOwnerCol,
			"scim_provisioned_user",
			false, // the key cannot change, so we do not need to track updates
			&migration.TriggerCondition{
				Column: projection.UserMetadataColumnKey,
				Value:  "urn:zitadel:scim:emails",
			},
		),
	}
}
